import queue
import random

from paulie.classifier.shape import Shape
from paulie.classifier.classification import Morph, Classification, TypeConnection, TypeStar

from paulie.common.pauli import is_commutate, multi_pauli_arrays, get_pauli_array
from paulie.graphs.subgraphs import get_subgraphs
from paulie.helpers.printing import print_node, print_nodes, print_lit_nodes
from paulie.helpers.recording import recording_graph
import sys, os, traceback
import copy

NUMB_ATTEMPTS = 1   #
NUMB_RESORTING = 1

class DependedException(Exception):
    pass

class AppendedException(Exception):
    pass

class DebugException(Exception):
    pass

def get_lits(lighting, nodes):
    """Return highlighted vertices (connected to the selected vertex)."""
    lits = []
    for node in nodes:
        if node != lighting:
           if is_commutate(lighting, node) is False:
               lits.append(node)
    return lits


def find_center_and_lits(nodes):
    """Find a center with maximum connections. And bring back these connections."""
    center = nodes[0]
    center_lits = []
    for node in nodes:
        lits = get_lits(node, nodes)
        if len(lits) > len(center_lits):
            center = node
            center_lits = lits
    return center, center_lits


def append_next_nodes(prepared_nodes, nodes):
    """Adding the next node according to the principle of having a connection with the previous one.
    
    If there are several connected ones, then we insert them after the first one. (To reduce the risk of graph
    reassembly).
    """
    for node in nodes:
        if node in prepared_nodes:
            nodes.remove(node)
            continue

        lits = get_lits(node, prepared_nodes)
        if len(lits) == 0:
            continue
        if len(lits) > 1:
           min_index = len(prepared_nodes)
           for lit in lits:
               index = prepared_nodes.index(lit)
               if index < min_index:
                   min_index = index
           prepared_nodes.insert(min_index + 1, node)
        else:
            prepared_nodes.append(node)
        nodes.remove(node)
        return


def prepare_nodes(nodes, debug=False):
    """Sorting nodes in order from the center and then by connections."""
    nodes = sorted(nodes)
    prepared_nodes = []
    center, lits =  find_center_and_lits(nodes)
    print_node(debug, center,"center")
    print_nodes(debug, lits, "lits")
    nodes.remove(center)
    prepared_nodes.append(center)

    for lit in lits:
        nodes.remove(lit)
        if lit not in prepared_nodes:
            prepared_nodes.append(lit)

    while len(nodes) > 0:
         append_next_nodes(prepared_nodes, nodes)

    return prepared_nodes


def append(nodes, vertix):
    nodes.append(get_pauli_array(vertix))

def test_vertixes():
    nodes = []
    append(nodes, "IIIYZI")
    append(nodes, "IIIIXX")
    append(nodes, "IIIIYZ")
    append(nodes, "IIIXXI")
    append(nodes, "IIXXII")
    append(nodes, "IYZIII")
    append(nodes, "YZIIII")
    append(nodes, "IIYZII")
    append(nodes, "IXXIII")
    append(nodes, "XXIIII")
    return nodes


def lit_vertix(morph, lighting, vertix):
    lighting = multi_pauli_arrays(lighting, vertix)
    if morph.is_included(lighting):
        print_node(morph.get_debug(), lighting, "depended")
        morph.print_state()
        raise DependedException()
    return lighting

def lit_canonic_position(morph, lighting, lits, debug, record):
    # lit center and unlit one legs
#    if lighting == get_pauli_array("IIIYZI"):
#        morph.append_to_center(lighting)
#        raise DebugException()
    is_break = False
    if lighting == get_pauli_array("IIIIXX"):
        is_break = True

    center = morph.get_center()
    one_lits, one_unlits = morph.get_one_lits_and_unlits(lits)
    if len(one_lits) > 0 and len(one_unlits) > 0:
    #Legs of length 1 are lit and unlit differently
    #We can switch the lit vertices by multiplying pq to unlit. This way we get an independent leg of length 2
        p = one_lits[0]
        q = one_unlits[0]
        pq = multi_pauli_arrays(p, q)
        for lit in lits:
            if lit != p:
                v = multi_pauli_arrays(pq, lit)
                morph.replace(lit, v)
        morph.append_to_one(lighting, p)
        #raise DebugException()
        raise AppendedException()

    if len(one_lits) > 0:
       if center in lits:
           lighting = lit_vertix(morph, lighting, center)
           one_unlits = one_lits.copy()
           one_lits = []
       else:
           lighting = lit_vertix(morph, lighting, one_lits[0])
           lighting = lit_vertix(morph, lighting, center)
           one_unlits = one_lits.copy()
           one_lits = []

    #one leg is unlited
    #center maybe lit and unlit

    vertices = morph.get_vertices()
    lits = get_lits(lighting, vertices)
    number_two_legs = morph.get_number_two_legs()
    long_leg = morph.get_long_leg()


    if number_two_legs > 0 and len(long_leg) == 4:
        two_all_lits, two_first_lits, two_second_lits, two_unlits = morph.get_two_lits_and_unlits(lits)

        if len(two_all_lits) == 0 and len(two_first_lits) == 0 and len(two_second_lits) == 0:
           # lit two legs
            v0 = two_unlits[0][0]
            v1 = two_unlits[0][1]
            long_leg, long_leg_lit_indexes = morph.get_long_lits_and_unlits(lits)
            first_lit_long = long_leg_lit_indexes[0]
            for i in range(first_lit_long, -1, -1):
                lighting = lit_vertix(morph, lighting, long_leg[i])

            lits = get_lits(lighting, vertices)
            if center not in lits:
                lighting = lit_vertix(morph, lighting, long_leg[0])


            lighting = lit_vertix(morph, lighting, center)
            lighting = lit_vertix(morph, lighting, one_unlits[0])
            lighting = lit_vertix(morph, lighting, v0)
            lighting = lit_vertix(morph, lighting, center)


    if number_two_legs > 0 and is_break:
        # reduce graph
        two_legs = morph.get_two_legs()
        v0 = two_legs[0][0]
        v1 = two_legs[0][1]
        v1_new = lit_vertix(morph, v1, v0)
        c_new = lit_vertix(morph, v1_new, center)
        morph.replace(v1, v1_new)
        morph.replace(center, c_new)
        if is_break:
            morph.append_to_center(lighting)
            raise DebugException()
        
#        morph.remove_last_from_two_leg(self, v1)
        #l = lit_vertix(morph, v1, v0)
        #l = lit_vertix(morph, l, center)
        #l = lit_vertix(morph, l, one_unlits[0])


    if number_two_legs > 1 and len(long_leg) == 0 or number_two_legs > 0 and len(long_leg) > 0:
         lits = get_lits(lighting, vertices)

         two_all_lits, two_first_lits, two_second_lits, two_unlits = morph.get_two_lits_and_unlits(lits)

         if len(two_all_lits) > 0 or len(two_first_lits) > 0 or len(two_second_lits) > 0:

            if len(vertices) > 7:
                print(f"number_two_legs = {number_two_legs} long legs = {len(long_leg)}")
                print(f"two_all_lits = {len(two_all_lits)} two_first_lits = {len(two_first_lits)} two_second_lits = {len(two_second_lits)} two_unlits = {len(two_unlits)}")





#            p = None
#            v1 = None
#            q = one_unlits[0]
#            if len(two_first_lits) > 0:
#                p = two_first_lits[0][0]
#                v1 = two_first_lits[0][1]
#                p = v0
#            else:
#                if len(two_all_lits) > 0:
#                    p = two_all_lits[0][0]
#                    v1 = two_all_lits[0][1]
#                    lighting = lit_vertix(morph, lighting, p)
#                else:
#                    p = two_second_lits[0][0]
#                    v1 = two_second_lits[0][1]
#                    lighting = lit_vertix(morph, lighting, v1)
#                    lighting = lit_vertix(morph, lighting, p)



#            pq = multi_pauli_arrays(p, q)
#            lits = get_lits(lighting, vertices)
#            if is_break:
#                morph.append_to_center(lighting)
#                raise DebugException()

#            for lit in lits:
#                if lit != p and lit != v1:
#                    v = multi_pauli_arrays(pq, lit)
#                    morph.replace(lit, v)
#            v1_new = multi_pauli_arrays(pq, v1)
#            morph.replace(v1, v1_new)

#            morph.replace(v1, lighting)

#            v1_new = lighting
#            lighting = v1

#            if is_break:
#                morph.append_to_center(lighting)
#                raise DebugException()

#            lighting = lit_vertix(morph, lighting, p)
#            center = morph.get_center()
#            lighting = lit_vertix(morph, lighting, center)
#            lighting = lit_vertix(morph, lighting, q)
#            lighting = lit_vertix(morph, lighting, v1_new)
#            lighting = lit_vertix(morph, lighting, p)
#            lighting = lit_vertix(morph, lighting, center)
#            morph.append_to_center(lighting)
#            raise DebugException()
#            raise AppendedException()
    else:
        if number_two_legs == 1:
            two_legs = morph.get_two_legs()
            print(f"two_legs = {two_legs}")
            v0 = two_legs[0][0]
            v1 = two_legs[0][1]
            if center in lits:
                if v0 in lits and v1 in lits:
                    lighting = lit_vertix(morph, lighting, center)
                    lighting = lit_vertix(morph, lighting, one_unlits[0])
                    lighting = lit_vertix(morph, lighting, v1)
                    lighting = lit_vertix(morph, lighting, v0)
                    lighting = lit_vertix(morph, lighting, center)
                    morph.append_to_center(lighting)
                    raise DebugException()
                    raise AppendedException()
                if v0 in lits:
                    lighting = lit_vertix(morph, lighting, v0)
                    lighting = lit_vertix(morph, lighting, v1)
                    morph.append_to_two(lighting, v1)
                    raise DebugException()
                    raise AppendedException()
                if v1 in lits:
                    lighting = lit_vertix(morph, lighting, v1)
                    lighting = lit_vertix(morph, lighting, center)
                    lighting = lit_vertix(morph, lighting, one_unlits[0])
                    lighting = lit_vertix(morph, lighting, v1)
                    lighting = lit_vertix(morph, lighting, v0)
                    lighting = lit_vertix(morph, lighting, center)
                    morph.append_to_center(lighting)
                    raise DebugException()
                    raise AppendedException()
            else:
                if v0 in lits and v1 in lits:
                    lighting = lit_vertix(morph, lighting, v1)
                    morph.append_to_two(lighting, v1)
                    raise DebugException()
                    raise AppendedException()
                if v0 in lits:
                    lighting = lit_vertix(morph, lighting, v0)
                    lighting = lit_vertix(morph, lighting, center)
                    lighting = lit_vertix(morph, lighting, one_unlits[0])
                    lighting = lit_vertix(morph, lighting, v1)
                    lighting = lit_vertix(morph, lighting, v0)
                    lighting = lit_vertix(morph, lighting, center)
                    morph.append_to_center(lighting)
                    raise DebugException()
                    raise AppendedException()
                if v1 in lits:
                    morph.append_to_two(lighting, v1)
                    raise AppendedException()

    if is_break:
        morph.append_to_center(lighting)
        raise DebugException()

    # lit only long leg    
    if center in lits:
        if len(lits) == 1:
             morph.append_to_center(lighting)
             raise AppendedException()

        return lighting

    long_leg, long_leg_lit_indexes = morph.get_long_lits_and_unlits(lits)
    if len(long_leg_lit_indexes) > 0:
        first_lit_long = long_leg_lit_indexes[0]
        for i in range(first_lit_long, -1, -1):
            lighting = lit_vertix(morph, lighting, long_leg[i])
        return lighting

    vertices = morph.get_vertices()
    lits = get_lits(lighting, vertices)
    print_lit_nodes(debug, vertices, lits, "lits star")
    morph.print_state()

    raise Exception("Can`t lit center")

def find_one_lit_on_long(morph, lighting, debug, record):
    center = morph.get_center()
    vertices = morph.get_vertices()
    lits = get_lits(lighting, vertices)
    print_lit_nodes(debug, vertices, lits, "lits on long")


    long_leg, long_leg_lit_indexes = morph.get_long_lits_and_unlits(lits)
    one_lits, one_unlits = morph.get_one_lits_and_unlits(lits)

    # center is lited
    # classify type adding
    lits = get_lits(lighting, long_leg)
    print_lit_nodes(debug, long_leg, lits, "lits on long leg A")


    ###### Нужно сдесь получить одну или две с 0 подсветки на ноге тогда мы можем это все классифицировать
    # это нужно сделат, после B

    if len(long_leg_lit_indexes) == 1 and 0 in long_leg_lit_indexes:
        number_two_legs = morph.get_number_two_legs()
        if number_two_legs > 0:
            return (lighting, center)
        # can add to end
        lits = get_lits(lighting, vertices)
        print_lit_nodes(debug, vertices, lits, "lits on long before")

        for i,v in enumerate(long_leg):
            #v = long_leg[i]
            lighting = lit_vertix(morph, lighting, v)
            lits = get_lits(lighting, vertices)
            print_lit_nodes(debug, vertices, lits, f"lits {i}")


        print_node(debug, lighting, "move to end")
        lit = long_leg[len(long_leg) - 1]

        lits = get_lits(lighting, vertices)
        print_lit_nodes(debug, vertices, lits, "lits on long after")

        return (lighting, lit)

    if len(long_leg_lit_indexes) == 1:
        morph.print_state()
        i = long_leg_lit_indexes[0]
        if i != len(long_leg) - 1:
            morph.append_to_center(lighting)
            raise DebugException()

            raise Exception("move more 1 from long is not implemented")
        morph.append_to_center(lighting)
        # replace i-1 generator on pq*generator
        lit = long_leg[i - 1]
        q = one_unlits[0]
        pq = multi_pauli_arrays(lighting, q)
        v = multi_pauli_arrays(pq, lit)
        morph.replace(lit, v)
        rv = long_leg[i]
        morph.remove_last_from_long_leg()
        morph.append_to_one(rv, lighting)

        vertices = morph.get_vertices()
        lits = get_lits(lighting, vertices)
        print_lit_nodes(debug, vertices, lits, "Transform A to B")
        morph.print_state()
        raise AppendedException()
        


    if len(long_leg_lit_indexes) == 2 and 0 in long_leg_lit_indexes and len(long_leg) - 1 in long_leg_lit_indexes:
        # can add to center
        lighting = lit_vertix(morph, lighting, center)
        lighting = lit_vertix(morph, lighting, one_unlits[0])
        for i in range(len(long_leg) - 1, -1, -1):
            v = long_leg[i]
            lighting = lit_vertix(morph, lighting, v)
        lighting = lit_vertix(morph, lighting, center)
        return (lighting, center)

     #### Тут нужно сделать новую ногу и сделать одну линой 2, и остаток длиной 4 или 3, после B

    vertices = morph.get_vertices()
    lits = get_lits(lighting, vertices)
    print_lit_nodes(debug, vertices, lits, "lits on star")



    raise Exception("trasform A to B is not implemetned")




 
def find_one_lit(morph, lighting, debug, record):
    print_node(debug, lighting, "find_one_lit")
    vertices = morph.get_vertices()
    lits = get_lits(lighting, vertices)
    center = morph.get_center()
    #print_lit_nodes(debug, vertices, lits, "find_one_lit")

    if len(vertices) == 1:
        if len(lits) == 1:
            return (lighting, lits[0])
        else:
            raise Exception("not connection")

    if len(vertices) == 2:
        if len(lits) == 1:
            if center in lits:
                return (lighting, center)
            else:
                lighting = lit_vertix(morph, lighting, lits[0])
                lighting = lit_vertix(morph, lighting, center)
                return (lighting, center)
        else: 
            if len(lits) == 2:
                lighting = lit_vertix(morph, lighting, center)
                return (lighting, center)
            else:
                raise Exception("not connection")

    lighting = lit_canonic_position(morph, lighting, lits, debug, record)
    # lit only long leg and center
    return find_one_lit_on_long(morph, lighting, debug, record) 

    return (lighting, None)


def append_morph(morph, pair, debug, record):
    if pair[1] is None:
        return False

    lighting = pair[0]
    lit = pair[1]
    is_can_append, type_graph, type_connection =  morph.is_can_append(lighting, lit)
    print_node(debug, lighting, "appending")
    if is_can_append:
        if type_connection == TypeConnection.CENTER:
            morph.append_to_center(lighting)
            return True
        if type_connection == TypeConnection.LONG:
            morph.append_to_long(lighting)
            return True
        if type_connection == TypeConnection.ONE:
            morph.append_to_one(lighting, lit)
            return True
        if type_connection == TypeConnection.TWO:
            morph.append_to_two(lighting, lit)
            return True

    return False



def build_morph(morph, lighting, debug, record):
    print_node(debug, lighting, "adding node")

    if morph.is_empty():
        morph.set_center(lighting)
        return True, False
 
    index = morph.find(lighting)
    if index > -1:
        return False, True

    is_depended = False
    try:
       pair = find_one_lit(morph, lighting, debug, record)
       is_appended = append_morph(morph, pair, debug, record)
    except DependedException:
        is_depended = True
        is_appended = False
    except AppendedException:
        is_appended = True

    vertices = morph.get_vertices()
    if len(vertices) > 9:
        raise DebugException()

    return is_appended, is_depended


def transform_to_canonic(nodes, debug=False, record=None):
    """Transform a connected graph to a cononic type."""
#    debug = False
    morph = Morph(debug)
    if len(nodes) == 0:
        return shape, nodes

    nodes = prepare_nodes(nodes, debug)
    #nodes = test_vertixes()
    print_nodes(debug, nodes, "init")

    recording_graph(record, nodes)
    unappended = []
    dependents = []

    while len(nodes) > 0:
        lighting = nodes[0]
#        if lighting == get_pauli_array("IIYZII"):
#            debug = True
#        else:
#            debug = False

        nodes.remove(lighting)
        is_exception = False
        try:
            is_appended, is_depended = build_morph(morph, lighting, debug, record)
            print_node(debug, lighting, f"is_appended = {is_appended}")
            if is_appended is False:
                if is_depended is False:
                    unappended.append(lighting)
                else:
                    dependents.append(lighting)
        except DebugException:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            print_node(debug, lighting, f"debug exception {traceback.format_exc()}")
            break
        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            ex = str(e) + " " + fname + " " +  str(exc_tb.tb_lineno)
            ex += str(traceback.format_exc())
            print_node(debug, lighting, f"exception {ex}")
            unappended.append(lighting)
            is_exception = False

        #recording_graph(record, isomorphisms.get_vertices())

        if is_exception:
            print_nodes(debug, nodes, f"nodes after exception")

    print_nodes(debug, unappended, f"unappended")
    print_nodes(debug, dependents, f"dependents")
    morph.print_state()

    return morph



def transform_to_canonics(nodes, debug=False, record=None):
    """Split the original graph into connected subgraphs and transform them to a cononical type."""
    subgraphs = get_subgraphs(nodes)
    canonics = []
    classification = Classification()

    for subgraph in subgraphs:
        classification.add(transform_to_canonic(subgraph, debug, record))
  
    return classification


def merge_canonics(canonics):
    """Merge cononic graphs."""
    nodes = []
    for canonic in canonics:
        for node in canonic["canonic"]:
            nodes.append(node)
    return nodes